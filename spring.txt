spring:
    1.概念
        1.分层的javase/ee应用full-stack轻量级开源框架
        2.内核:ioc:反转控制;aop:面向切面编程
        3.提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等
    2.快速入门
        1.在pom.xml中导入spring坐标
            <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-context</artifactId>
              <version>5.2.12.RELEASE</version>
            </dependency>
        2.创建接口和接口实现类,创建Bean
        3.创建spring配置文件,applicationContext,并配置Bean
            <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl"></bean>
        4.创建ApplicationContext对象.getBean()获取指定Bean
            ApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml");
            UserDao userDao = (UserDao) app.getBean("UserDao");
    3.Spring的配置文件
        1.Bean标签的基本配置
            1.形式:
                <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl"></bean>
            2.作用:
                用于配置对象交由Spring来创建
                *默认情况下调用的是类中的无参构造函数,如果没有无参构造函数则不能创建成功
            3.基本属性
                id: Bean实例在Spring容器中的唯一性标识
                class: 全限定名,指向实现类
        2.Bean标签的范围配置
            1.scope的取值
                singleton       默认值,单例
                prototype       多例的
                request         WEB项目中,Spring创建一个Bean对象,将对象存入到request域中
                session         WEB项目中,Spring创建一个Bean对象,将对象存入到session域中
                global session  WEB项目中,应用在Portlet环境,如果没有Portlet环境那么global session相当于session
            2.scope="singleton"
                实例化个数: 1
                实例化时机: Spring的核心配置文件applicationContext.xml被加载时,实例化Bean
                Bean的生命周期:
                    1.对象创建: 当应用加载,创建容器时
                    2.对象运行: 只要容器存在,对象一直存在
                    3.对象销毁: 当应用卸载,销毁容器时,对象被销毁
            3.scope="prototype"
                实例化个数: 多个
                实例化时机: 调用getBean()时,实例化Bean
                Bean的生命周期:
                    1.对象创建: 当使用对象时,创建新的对象实例
                    2.对象运行: 只要对象被使用,就一直存在
                    3.对象销毁: 当对象长时间爱你不使用时,被gc回收
        3.Bean生命周期配置
            init-method: 指定类中初始化方法名称
            destroy-method: 指定类中销毁方法名称
                <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl" scope="singleton" init-method="init" destroy-method="destroy"></bean>
                public void init(){
                    System.out.println("初始化方法..");
                }
                public void destroy(){
                    System.out.println("销毁方法..");
                }
        4.Bean实例化的三种方式
            1.无参构造 -> 最常用
            2.工厂静态
                <bean id="staticFactory" class="com.qyj.factory.StaticFactory" factory-method="getUserDao"></bean>
            3.工厂实例
                <bean id="dynamicFactory" class="com.qyj.factory.DynamicFactory"></bean>
                <bean id="UserDao" factory-bean="dynamicFactory" factory-method="getUserDao"></bean>
                *工厂使用时机:需要使用参数实例化对象的时候
        5.Bean依赖注入例子
            1.在service层实现
                public class UserServiceImpl implements UserService {
                    @Override
                    public void save() {
                        ApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml");
                        UserDao userDao = (UserDao) app.getBean("UserDao");
                        userDao.save();
                    }
                }
            2.配置service层的bean
                <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl"></bean>
                <bean id="UserService" class="com.qyj.service.impl.UserServiceImpl"></bean>
            3.实现测试
                @Test
                public void test6(){
                    ApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml");
                    UserService userService = (UserService) app.getBean("UserService");
                    userService.save();
                }
            4.注入分析
                UserService和UserDao都在spring容器内部
                而最终使用的是UserService -> UserService依赖于UserDao
                因此可以在容器中就把UserDao设置到UserService内部
        6.Bean的依赖注入概念:
            依赖注入:是Spring框架核心IOC的具体体现

            在编写程序是,通过控制反转,把对象的创建交给了Spring,但是代码中不可能出现没有依赖的情况
            IOC解耦只是降低他们的依赖关系,但不会消除.
            例如:业务层仍会调用持久层的方法,此例中的UserService依然会使用UserDao

            这种业务层和持久层的依赖关系,在使用Spring之后,就让Spring来维护,简单地说就是让框架将持久层对象传入业务层,而不用我们自己去获取
        7.Bean的依赖注入方式:
            1.构造方法
            2.set方法
                1.在依赖对象实例中创建被依赖对象的实例并添加set方法
                    public class UserServiceImpl implements UserService {

                        private UserDao userDao;

                        public void setUserDao(UserDao userDao) {
                            this.userDao = userDao;
                        }

                        @Override
                        public void save() {
                            userDao.save();
                        }
                    }
                2.在配置文件中配置属性
                    <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl"></bean>
                    <bean id="UserService" class="com.qyj.service.impl.UserServiceImpl">
                        <property name="userDao" ref="UserDao"></property>
                    </bean>
                        *name: set方法去除set后首字母改小写
                        *ref: 对应set设置的对象的Bean id
                3.p命名空间形式
                    xmlns:p="http://www.springframework.org/schema/p"
                    <bean id="UserDao" class="com.qyj.dao.impl.UserDaoImpl"></bean>
                    <bean id="UserService" class="com.qyj.service.impl.UserServiceImpl" p:userDao-ref="UserDao"></bean>
                        *p:userDao-ref="UserDao"
                            userDao 对应name的属性
                            "UserDao" 对应ref的属性









